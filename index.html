<!DOCTYPE html>
<html>
<head>
<title>Polaroids</title>
<style>
html, body {
  margin: 0;
}
</style>
<script src="thre.min.js.110"></script>
<script src="shaders.js"></script>
</head>
<body>
</body>
<script>
const FILENAME = 'me2.jpg';

const width = window.innerWidth;
const height = window.innerHeight;

// Three
// const projection = {
//   angle: 45,
//   aspect: W / H,
//   near: 0.1,
//   far: 10000
// };
// 
// const camera = new THREE.PerspectiveCamera(
//   projection.angle,
//   projection.aspect,
//   projection.near,
//   projection.far
// );
// camera.position.set( 20, 40, 400 );


const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(0 , width, height, 0, 1, 1000);
camera.position.z = 100;
const renderer = new THREE.WebGLRenderer({antialias: true});
const texture = new THREE.TextureLoader().load( FILENAME, run );



function run(texture) {
  console.log('run', texture);
  console.log(`\twidth ${texture.image.width}`);
  console.log(`\theight ${texture.image.height}`);

  renderer.setSize(width, height);
  const body = document.body;
  body.appendChild(renderer.domElement);
  scene.add(camera);

  // Test
  // const pointLight = new THREE.PointLight(0xFFFFFF);
  // pointLight.position.x = 10;
  // pointLight.position.y = 50;
  // pointLight.position.z = 400;
  // scene.add(pointLight);

  // const xaxis = new THREE.Geometry();
  // xaxis.vertices.push(new THREE.Vector3(-9999, 0, 0));
  // xaxis.vertices.push(new THREE.Vector3(9999, 0, 0));
  // scene.add(new THREE.Line( xaxis, new THREE.MeshBasicMaterial({ color: '#F88' })));
  // 
  // const yaxis = new THREE.Geometry();
  // yaxis.vertices.push(new THREE.Vector3(0, -9999, 0));
  // yaxis.vertices.push(new THREE.Vector3(0, 9999, 0));
  // scene.add(new THREE.Line( yaxis, new THREE.MeshBasicMaterial({ color: '#8F8' })));
  // 
  // const zaxis = new THREE.Geometry();
  // zaxis.vertices.push(new THREE.Vector3(0, 0, -9999));
  // zaxis.vertices.push(new THREE.Vector3(0, 0, 9999));
  // scene.add(new THREE.Line( zaxis, new THREE.MeshBasicMaterial({ color: '#88F' })));


  const buffer = renderMaskingBuffer();
  processBuffer(buffer, texture); 

  // animate();
}


function createSQ(px, py, rz, len, isFrame) {
  let mesh, geometry, material;
  let x1 = 0; 
  let y1 = 0;
  let x2 = len;
  let y2 = len + 10;

  if (isFrame < 1.0) {
    x1 += 4; 
    y1 += 20; 
    x2 -= 4; 
    y2 -= 6; 
  }

  let cx = 0.5 * width;
  let cy = 0.5 * height;

  let F1 = { x: x1, y: y1 };
  let F2 = { x: x2, y: y2 };

  geometry = new THREE.Geometry();
  geometry.vertices.push( new THREE.Vector3( F1.x, F1.y, 2 ) );
  geometry.vertices.push( new THREE.Vector3( F2.x, F1.y, 2 ) );
  geometry.vertices.push( new THREE.Vector3( F2.x, F2.y, 2 ) );
  geometry.vertices.push( new THREE.Vector3( F1.x, F2.y, 2 ) );
  geometry.faces.push( new THREE.Face3( 0, 1, 2 ) ); // counter-clockwise winding order
  geometry.faces.push( new THREE.Face3( 0, 2, 3 ) );
  geometry.computeFaceNormals();

  let uniforms = {};
  uniforms.isFrame = {
    type: 'f', value: isFrame
  };

  material = new THREE.ShaderMaterial( {
    uniforms: uniforms,
    // vertexShader: document.getElementById( 'vertexShader' ).textContent,
    fragmentShader: maskFragShader,
    depthTest: false
  });
  

  mesh = new THREE.Mesh( geometry, material);
  mesh.position.x = cx + px;
  mesh.position.y = cy + py;
  mesh.rotation.z = rz;
  return mesh;
}

function seed(scene) {
}

function renderMaskingBuffer() {
  const scene = new THREE.Scene();
  scene.add(camera);
  seed(scene);

  // FIXME If just do width, height it becomes jagged ????? Filter issues?
  const textureBuffer = new THREE.WebGLRenderTarget(width, height, { 
    minFilter: THREE.NearestMipMapNearestFilter, 
    magFilter: THREE.LinearMipMapLinearFilter,
  }); 

  renderer.setRenderTarget(textureBuffer);
  renderer.render(scene, camera);
  renderer.setRenderTarget(null);
  return textureBuffer;
}


function processBuffer(buffer, texture) {
  const materialT = new THREE.ShaderMaterial( {
    uniforms: { 
      tImage: { type: 't',  value: texture},
      tDiffuse: { type: 't', value: buffer},
      width: { type: 'f', value: width},
      height: { type: 'f', value: height},
      blurSize: { type: 'i', value: 4}
    },
    vertexShader: vertexShader,
    fragmentShader: screenFragShader,
    depthWrite: false
  });

  var plane = new THREE.PlaneGeometry(width, height);
  var quad = new THREE.Mesh( plane, materialT );
  quad.position.x = width / 2;
  quad.position.y = height / 2;


  scene2 = new THREE.Scene();
  scene2.add(camera)
  scene2.add( quad );
  renderer.render(scene2, camera);
}



function render() {
  renderer.render(scene, camera);
}


function animate() {
	requestAnimationFrame( animate );
  render();
}



</script>
</html>

